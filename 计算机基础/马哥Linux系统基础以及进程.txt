静态角度看 操作系统的组成部分:

计算机 由:软+硬件 

从下到上:  1. 硬件   2.内核（操作系统,所属接口是system call(系统调用),系统调用是在内核中发生的） 3.由于不利于编程于是就有了    4.library call((库调用，库调用有些是独立的模块；有些还要对系统调用进行一次二次封装) 
5.程序员有可能面向系统调用来编程；也有可能面向库调用来编程；也有可能是混合编程，即面向库调用和系统调用来编程
调用  就是事先载入 别人写好的功能模块 比如函数


过程式编程语言是函数  对象式编程语言是类！！


特权指令 对完成对硬件的管理工作，这个特权指令只能内核来执行。比如 对硬盘和内存

某个 应用程序 需要对硬件进行管理操作时，要发起系统调用；任何需要用到特权指令的功能，操作系统都将其封装成一个调用，任何程序都不的直接操作，必须向内核申请调用等待其内核执行你的调用请求才可以。
程序再向内核申请调用这时就已经停止了（软中断），内核把你调用的功能放在cpu上，而不是你自己去执行，执行完毕，再将结果告诉你（返回）。这时你继续执行其他的流程


整个系统执行过程就是:不断的在执行用户代码和执行内核代码之间发生转换（一会在执行用户模式，一会在执行内核模式。这叫模式切换）

执行用户代码的机制 叫用户空间或用户模式（cpu运行在用户模式下）
用户模式下发起了系统调用，执行内核代码的机制 这时就执行内核代码，叫内核空间（内核模式）


内核的功能:进程管理，文件系统，网络功能，程序包的封包或拆包，内存，安全，驱动程序
 
 
一党专政 假装很民主  漂亮的不像实力派


cpu执行多进程是采用分时执行

切换时间片 多个进程轮流执行时间片，  如果一个进程霸占cpu不走，让一个特权更高的人即内核将他T掉，维护公平与正义

进程管理最大的一部分叫进程调度:内核负责将运行中的程序按划分成时间片，根据其优先级将它调度到cpu执行，比如划分成5毫秒，到了这个时间，保存当前程序执行的状态(保存到cpu的寄存器里。
寄存器就会保存进程状态叫保存现场，下次继续执行这个进程时叫恢复现场。保存进程恢复进程之间作切换也需要时间)，

以至于下次不会从头开始。执行下一个

process:运行中的程序的一个副本

进程是动态的，有自己的生命周期:出生日期（创建时间）   存活期  结束期
程序是静态的文件。

进程描述信息或属性保存在内核里的

内核为每一个运行在当前系统的所有进程空间都要给他创建一个用来追究进程的 源数据结构（进程属性）
描述存储数据的数据结构叫结构体（特定用来存储特定内容的一个固定的组织机制或组织格式）

描述一种或一类数据，必须按照特定的结构把数据组织在一起，这种机制叫做数据结构

对于进程而言，内核中所使用的结构体叫 任务结构体

Linux内核存储进程信息的固定格式叫 task   struct

内核为每一个进程存储一个结构体
多个任务的task struct组件的 链表 :task list


进程如何创建的？

运行一个程序（指令+数据）就创建了一个进程。比如你输入了指令 ls -l,此时 就创建了一个进程。

系统开机，先把内核代码放在cpu运行，待内核掌管一切后，由内核负责启动进程，他会派一个使者管理进程。开始创建第一个进程，该进程叫初始化进程。
后续用户空间的所有管理工作就由 init这个使者来管理，init不能代替上帝（内核）比如系统调用等一切特权指令的执行，但是创建进程，由Init负责向上帝提交。

它是总的负责一切进程用户空间进行管理的这么一个进程，而它（init）开始创建子进程,或者是它的子进程创建出的子进程
除了初始化 进程，init是上帝创造的，你不是上帝创造的，你是你父母所生的，所有进程都是由其 父进程创建。
 父进程如何创建子进程:
父进程创建子进程是由fork自身而来，内核都有一个系统调用，叫fork.父进程需要创建子进程时，需要向内核发起请求（系统调用，fork。这里的fork俨然成了办准生证的大门）。    
比如你俩要造人 ，你是没有权限的，需要向党组织申请准生证，不是说你想造多少就造多少。

子进程不能脱离父进程存活，需要同处一室共享数据（使用同一段内存空间，子进程也会有自己的名字，id）；长大了，子进程娶妻生子了，千百年来的传统，婆媳问题真是难搞，哎，分家分家！！！

子进程需要修改进程空间数据时，父进程是不允许的。。。。此时父进程就复制自己的一份数据给子进程，子进程想怎么改就怎么改。这种机制叫 cow。

进程的终止:
世间都是黑发人送白发人，然而进程是白发人送黑发人！子进程由父进程负责销毁！


父进程创建子进程的目的是在某一时刻  父进程可能会执行很多复杂的任务，希望子进程帮他处理（子进程处理时，父进程以静默方式存在，等待子进程执行完成）。子进程执行完成，那么子进程的使命已经结束了，就该退去了！
父进程继续执行它的任务