内存是一个编址的存储设备

基础的运算器是:加法器

加数 +  被加数

加法器的运算输入数据在哪里？
计算机只识别二进制！！

由于电流电压电阻的原因，无法使用十进制（0-9）精确的表示电流的状态

所以只使用二进制 有/无电  来表示状态，不管你电流大小。


利用电路的闭合开关来完成计算机的逻辑运算，再把逻辑运算转换成算术运算


电流从负极流到正极



存储器 保存了电压。  也就是可以转换成电路信号的电压（磁型号转换成电信号）
每进行一次加法运算 ，运算器需要先获取加数与被加数，到哪里去获取加数和被加数？从存储器里获取加数和被加数，哪一个数据是存储器所需要的？
程序由数据和指令构成。指令会告诉cpu， 在哪一个存储器的哪一个单元是存放的加数，哪一个单元是放的被加数
运算器（cpu）要想运算数据，首先cpu会从内存里读取指令,指令会告诉cpu，加数在什么地方。加数在什么地方，谁来控制读取？
接下来依靠控制器的协调到存储器的某一个存储单元里把数据读取给cpu里 ，把数据读取交给cpu。 具体数据在内存的位置。cpu才能从内存读取数据

存取数据到内存的操作是控制器在执行

内存里有数据和指令

控制器需要接受控制指令 同时，运算器要想运算数据，必须要先取得数据
传输数据的线路叫数据总线
对于控制器而言:控制器去获取控制指令的线路叫控制总线


线路复用；传输线路既可以传输加数，又可以传输被加数，还可以传输指令

由于线路复用，且写入的数据有清空写入的特点，为了保存数据，运算器里有一个寄存器。用于临时接收数据并存储，然后在参与运算

借助硬件，模拟出来的设备就叫虚拟机。由硬件+软件构成


加电自检：就是开机的那一刻将rom的指令映射给内存，然后再按cpu工作流程来处理

轮巡:cpu不停的来查看 用户是否有新的操作。这个过程叫pool.
后来，改用了下面这种方式:

用户敲击键盘，会产生一个电信号通知cpu，cpu会过来看用户敲击的键盘指令。这个过程叫中断,英文interrupt

跟cpu针脚相连的，有一个控制芯片。控制芯片的每一根线都分配给一个设备使用，比如键盘，鼠标等。当有事件产生时，cpu查看 控制芯片，根据 事件产生时所对应的针脚，而得知是哪个设备进行的.然后cpu通知内核去完成cpu所识别到的这些意图




高速总线:北桥 （cpu,内存,显卡）

低速总线:南桥

南桥连接所有外围设备，经过一条线连接至北桥，再经北桥连接至cpu

现在内存不再经过北桥，直接交给cpu.也有将硬盘,vga直接连接至北桥

异步通行 和 同步同行

缓存:指令缓存  数据缓存  二级缓存 三级缓存




机器本身只识别 二进制语言 ，就是机器语言。由于开发难度大

厂商会在芯片上附加一个微码接口，方便程序员写程序。但是这种问题是各家厂商芯片的微码接口不一样，意味着我在这台电脑上写的程序能运行，到了其他电脑上就不能运行。，加上每个平台的硬件设备的逻辑与二进制的格式不一致
为此为了解决这种移植性，希望我一次开发程序能够在所有设备上运行。


api:应用编程接口。硬件与软件之间的，将不同规格硬件实现一个统一的标准接口
在不同cpu设备上使用汇编语言，而写出来的具有相同功能的程序，提供给上层程序（虚拟了相同程序的执行环境）
api将底层芯片的功能使用软件的方式抽象出来。
就有了 高级语言


硬件平台架构:
				intel之前，都是用摩托罗拉的cpu
			 ARM架构:英国的一家公司只设计芯片。Android实质是Linux系统
			 x86:32位平台:简单点就是说一条大马路并行32车道
			 x64:64位平台:一条大马路并行64车道
			 
			 惠普：有安腾(卖给intel),alpha cpu;
			 
			 
			 前sun公司的  UltraSparc
			 power
			 
			 苹果,摩托罗拉,ibm联合生产了powerpc cpu,早期的mac os只能用在这个cpu
			 
			 
			 
操作系统:
	os/2:由微软和IBM公司共同创造，后来由IBM单独开发的一套操作系统
	
	
某一时刻 cpu只能进行一个运算

计算机上，运行了一次完整的计算过程叫作业。多个作业叫jobs.
批处理:早期执行磁带机，为了执行多个任务。执行一次任务，后面以特殊符号隔开，再执行下一个任务。由于内存只有一段。所以只能运行一个程序。否则，交叉执行，一部分会被清空写入，数据就丢了
			 
			 
多任务系统:将一个资源分成多个资源。而计算机需要两个核心组件:cpu和内存。那么如何将一个资源分成多个资源。
所有待处理的程序都排成一个阵列，依次排队，当进行第一个的时候，cpu会根据实际情况会中断这个程序，此刻将已经处理了的保存起来，执行下一个，以此类推，然后下次再从这次终止的地方继续执行。






	内存分段。一个程序访问一段内存，另一个程序就没法用。cpu也只有一颗。进行一个程序的运算，就没法进行第二个程序的运算
	将一个资源分成多个资源。而计算机需要两个核心组件:cpu和内存。
	比如 大脑想第一件事需要10s,想第二件事也需要10s.怎么同时想两件事？怎么让第一件事跟第二件事同时想
	那可以第一件事想1s,停下来，保存起来;然后想第二件事1s，停下来，保存起来;然后再回过头来从上次停止的那个地方想第一件事，保存起来，从上次停止的第二个地方想第二件事,但是每次两件事的1s的结果保存在哪里？这种叫保护现场




进程:进程是如何工作地？
	要将cpu进行切分。怎么切分的？cpu的运算是随着时间的流逝而完成的。时间驱动的。因此把cpu划分成了计算时间，叫时间片（slice）。
	
	
	slice:将如说一个时间片是5ms.那么运行第一个程序5ms.运行第二个程序也是5ms。不停地进行交替
	
内存是怎么划分的?

内存分成两半，一个程序访问前半段，另一个程序访问后半段。第二个程序如何知道自己是该访问后半段。

内存分段:
内存分段机制:
第一个程序执行的时候就把cpu分成两段:1,2

但是对于每一段来讲都有自己的编号0.1.2.3.4 .也就是说两段都有自己的起始位。即两段都有自己的0.1.2.3.4
所以，第一个程序有自己的1，第二个程序也有自己的1


虚拟地址空间:不是虚拟内存。程序员开发程序不再关心你还有多少物理内存。

32位cpu一共最多能引用多少个不同的地址？2（32）；
每一个程序在运行的时候都有自己的一个虚拟地址的空间


负责监控，协调内存里程序的运行是操作系统。操作系统运行在硬件之上，负责管理硬件资源，将硬件资源所提供的计算能力，cpu切割成多个片，分配给多个不同的程序，内存分成多个段分配给不同的程序，并且在他们之间完成协调

操作系统还负责完成程序的启动，终止，回收，切换等工作。这时将操作系统里运行的每个实例叫进程。进程是一个处理过程。程序结束了也就没有了。也就是说进程有自己的生命周期。从启动到结束

操作系统将硬件所提供的计算能力使用软件的方式模拟出来。做了二次模拟。所以任何程序看到的不再是硬件本身，而是操作系统所提供的接口。操作系统的功能接口为了尽可能简化或者尽可能少一点，把它做得非常底层。而操作系统的接口叫system call(系统调用)。有了操作系统。任何程序都不能与硬件打交道。要想使用硬件功能必须通过操作系统来进行协调
库:被其他程序调用，只能被调用。将底层系统调用一个或者多个封装起来做成更高级的接口。这个高级接口就是库！。英文叫做lib,接口名称:api;
将应用程序与内核隔离开来


shell:包含图形界面的shell(gui).一种是字符界面的shell(cli);

























